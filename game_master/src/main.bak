//ACTEL_STDIO_THRU_UART - add to hardware symbols for printf

#include "N64/N64.h"
#include "robot/robot.h"
#include "led/led.h"
//#include "grid/grid.h"
#include "path/path.h"
#include "string.h"
#include "led/color_util.h"
#include "usleep.h"

#define NUM_PLAYERS 2

uint8_t _COLOR_BLACK[3] 		= {0, 0, 0};
uint8_t _COLOR_RED[3] 		= {255, 0, 0};
uint8_t _COLOR_GREEN[3] 		= {0, 255, 0};
uint8_t _COLOR_BLUE[3] 		= {0, 0, 255};
uint8_t _COLOR_YELLOW[3] 	= {255, 255, 0};
uint8_t _COLOR_MAGENTA[3] 	= {255, 0, 255};
uint8_t _COLOR_AQUA[3] 		= {0, 255, 255};
uint8_t _COLOR_WHITE[3] 		= {255, 255, 255};
uint8_t _COLOR_VIOLET[3] 	= {127, 0, 255};

volatile uint32_t *LED_UART_ADDR = (uint32_t *)0x40052000;
volatile uint32_t *N64_ADDR = (uint32_t *)0x40050000;

struct N64Inst_t n64;
struct Robot players[NUM_PLAYERS];
led_inst_t leds;
grid_t wall_grid;
path_t ghostPath;
cell_t playerPos = (cell_t){ 0, 0 }, ghostPos = (cell_t){ 10, 17 };
size_t playerIdx;
size_t ghostIdx;
size_t prevPlayerIdx;
size_t prevGhostIdx;

const char *wall_grid_txt[] =
{
	"0011111111111111111",
	"0011011110000000001",
	"1011000011101110001",
	"1011000000000010001",
	"1011010001111111111",
	"1000010000000000000",
	"1111110111111111111",
	"1000000000000000001",
	"1000000100000000001",
	"1111111111111111101",
	"0000000000000000000",
	"0000000000000000000"
};

const char *wall_grid_txt2[] =
{
	"0000000000000000000",
	"0000000000000000000",
	"0000000000000000000",
	"0000000000000000000",
	"0000000000000000000",
	"0000000000000000000",
	"0000000000000000000",
	"0000000000000000000",
	"0111111111111111100",
	"0000000000000000001",
	"0000000000000000000",
	"0000000000000000000"
};

const char *wall_grid_txt3[] =
{
	"1111111111111111111",
	"1000000000000000001",
	"1000000000000000001",
	"1000000000000000001",
	"1000000000000000001",
	"1000000000000000001",
	"1000000000000000001",
	"1000000000000000001",
	"1000000000000000001",
	"1000000000000000001",
	"1000000000000000001",
	"1111111111111111111"
};

__attribute__ ((interrupt)) void Fabric_IRQHandler( void )
{
	N64GetState(&n64);
	//N64PrintState(&inst, 1);
}

struct Point GetLocFromColor(uint16_t color)
{
	return (struct Point){0, 0};
}

void master_robot_rcv(const struct Robot *robot)
{
	robot_id_t rid = RobotGetId(robot);
	size_t i;
	for (i = 0; i < NUM_PLAYERS; i++)
	{
		if (RobotGetId(players + i) == rid)
		{
			// get location from color
			uint16_t color = RobotGetColor(players + i);
			uint8_t x = 0, y = 0;
			// set location
			RobotSetLoc(players + i, x, y);
		}
	}
	//RobotPrint(&robot);
}

int move_white = 1;

void set_move_white_led()
{
	move_white = 1;
}

void move_piece(led_inst_t *led_inst, size_t prevIdx, size_t newIdx)
{
	// send piece color back and bring previous color to forefront
	led_swap(led_inst, prevIdx, 0, prevIdx, 2);
	// swap piece positions
	led_swap(led_inst, newIdx, 2, prevIdx, 2);
	// bring piece color to forefront
	led_swap(led_inst, newIdx, 0, newIdx, 2);
	// swap in buffer 1
	led_swap(led_inst, newIdx, 1, prevIdx, 1);
}

int main(void) {
	N64Init(&n64, (uint32_t *)0x4005000);
	grid_init_file(&wall_grid, wall_grid_txt2, 12, 19);
	led_init_grid(&leds, &wall_grid, 3, LED_UART_ADDR);
	led_set_colors(&leds, 0, 12*19, 1, _COLOR_BLACK);
	//set_colors_hsv(&led, 0);
	//uint8_t rgb_white[3] = {10,10,40};
	//uint8_t rgb_powerup[3] =  {0,120,200};
	//led_set_colors(&leds, 0, 12*19, 0, rgb_white);
	//uint8_t green[3] = {0,51,5};
	//led_set_color(&leds, 12*19-1, 0, green);
	//led_send(&leds, 0, 1000000);

//while(1);
	//path_t ghostPath;
	memset(&ghostPath, 0, sizeof(ghostPath));
	playerIdx = led_grid_idx_to_strip_idx(&leds, playerPos.row, playerPos.col);
	ghostIdx = led_grid_idx_to_strip_idx(&leds, ghostPos.row, ghostPos.col);
	led_set_color(&leds, playerIdx, 2, _COLOR_WHITE);
	led_set_color(&leds, ghostIdx, 2, _COLOR_BLUE);
	led_swap(&leds, playerIdx, 0, playerIdx, 2);
	led_swap(&leds, ghostIdx, 0, ghostIdx, 2);

	cell_t pos1 = (cell_t){11, 0}, pos2 = (cell_t){11, 18};
	cell_t pos3 = (cell_t){10, 0}, pos4 = (cell_t){10, 18};
	set_colors_hsv_range(&leds, led_grid_idx_to_strip_idx(&leds, pos2.row, pos2.col),
			led_grid_idx_to_strip_idx(&leds, pos1.row, pos1.col) + 1, 0);
	set_colors_hsv_range(&leds, led_grid_idx_to_strip_idx(&leds, pos3.row, pos3.col),
				led_grid_idx_to_strip_idx(&leds, pos4.row, pos4.col) + 1, 0);
	//led_set_colors(&leds, 0, 19*12, 0, _COLOR_RED);
	while (1)
	{
		//led_send(&leds, 0, 1000000);
		//continue;
		if (move_white)
		{
			move_white = 0;
			cell_t prevPlayerPos = playerPos;
			cell_t prevGhostPos = ghostPos;

			// change player position
			if (N64ButtonPressed(&n64, BUTTON_DU))
				playerPos.col = playerPos.col == 18 ? playerPos.col : playerPos.col + 1;
			else if (N64ButtonPressed(&n64, BUTTON_DD))
				playerPos.col = playerPos.col == 0 ? playerPos.col : playerPos.col - 1;
			else if (N64ButtonPressed(&n64, BUTTON_DL))
				playerPos.row = playerPos.row == 11 ? playerPos.row : playerPos.row + 1;
			else if (N64ButtonPressed(&n64, BUTTON_DR))
				playerPos.row = playerPos.row == 0 ? playerPos.row : playerPos.row - 1;
			// don't move there if occupied
			if (grid_get_occupancy(&wall_grid, playerPos) == '1')
				playerPos = (cell_t){ prevPlayerPos.row, prevPlayerPos.col };

			prevPlayerIdx = led_grid_idx_to_strip_idx(&leds, prevPlayerPos.row, prevPlayerPos.col);
			playerIdx = led_grid_idx_to_strip_idx(&leds, playerPos.row, playerPos.col);
			if (prevPlayerIdx != playerIdx)
			{
				// recalculate path
				array_cell_t_destroy(&ghostPath);
				ghostPath = path_get(&wall_grid, ghostPos, playerPos);
				// move in leds
				move_piece(&leds, prevPlayerIdx, playerIdx);
			}

			/*if (!array_cell_t_empty(&ghostPath))
				ghostPos = array_cell_t_pop(&ghostPath);*/
			prevGhostIdx = led_grid_idx_to_strip_idx(&leds, prevGhostPos.row, prevGhostPos.col);
			ghostIdx = led_grid_idx_to_strip_idx(&leds, ghostPos.row, ghostPos.col);
			if (prevGhostIdx != ghostIdx)
			{
				// move in leds
				move_piece(&leds, prevGhostIdx, ghostIdx);
			}
			if (ghostIdx == playerIdx)
				break;
			/*if (playerPos.row == 5 && playerPos.col == 18)
				break;*/
			set_timer(1000000, 96000000, &set_move_white_led);
		}
		//led_pwm(&leds, 0, 1, 3000, 0.1);
		led_send(&leds, 0, 1000000);
	}

	led_rand_show(&leds, 0, 12*19, 0, 1000000, 300000000);

	led_destroy(&leds);
    return 0;
}
